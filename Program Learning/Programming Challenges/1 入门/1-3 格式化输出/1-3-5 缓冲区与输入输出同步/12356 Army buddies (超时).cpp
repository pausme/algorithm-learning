//
// Created by zx208 on 2023/8/31.
//
/*
 * Nlogonia正在与邻国库比科尼亚进行一场残酷的战争。
 * 诺罗尼亚军队的总司令决定以线性的士兵编队攻击敌人，他们将一起前进，直到征服邻国。
 * 战斗前，总司令下令，每一名在进攻线上的士兵，
 * 除了保护自己和进攻外，还应该保护他在队伍中的两个（最近的）邻居，一个在他的左边，一个是在他的右边。
 * 总司令告诉士兵们，对于他们每个人来说，如果存在这样的邻居，
 * 他的“伙伴”就是这两个邻居（因为最左边的士兵没有左边的邻居，最右边的士兵没有右边的邻居）。
 * 总司令还告诉士兵们，保护他们的战友对于防止攻击线被打破非常重要。
 * 非常重要的是，如果士兵的左边或右边的伙伴被杀，那么士兵左边或右边下一个活着的邻居应该分别成为他的伙伴。
 * 战斗非常激烈，许多在攻击线上的士兵被炮火、手榴弹和炸弹。
 * 但根据总司令的命令，在得知攻击线的损失后，陆军信息系统师必须立即通知士兵他们的新伙伴是谁。
 * 你会得到攻击线上的士兵人数，以及一系列损失报告。
 * 每一份损失报告都描述了攻击线上一群刚刚在战斗中丧生的连续士兵。
 * 编写一个程序，为每个损失报告打印新的伙伴。
 * 每个测试用例都用几行描述。第一条输入线包含两个整数S和B，分别表示攻击线上的士兵数量和损失报告数量。
 * 根据士兵在攻击线上的位置，士兵由1到S的不同整数标识，1是最左边的士兵，S是最右边的士兵。
 * 接下来的B输入行中的每一行都使用两个整数L（左）和R（右）来描述损失报告，这意味着从L到R的士兵被杀。
 * 你可能会认为，直到那一刻，那些士兵还活着，只是被杀了。
 * 对于每个测试用例，输出B+1行。
 * 在第i条输出线中，根据第i条损失报告，将刚刚被杀的士兵从攻击线上移除，从而形成新的伙伴关系。
 * 也就是说，对于损失报告“L R”，将第一名幸存士兵打印到L的左侧，将第一个幸存士兵打印在R的右侧。
 * 对于每个方向，如果该方向上没有幸存士兵，则打印字符“*”（星号）。
 * 在每个测试用例后打印一行，其中包含一个字符“-”（连字符）。
 */
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];

int main(){
    int S, B;
    while(cin >> S >> B, S && B){
        memset(a, 0, sizeof a);
        for (int i = 0; i < B; ++i) {
            int L, R, SL = 0, SR = 0;
            bool isL = false, isr = false;
            cin >> L >> R;
            for (int j = L; j <= R; ++j) {
                a[j] = 1;
            }
            for (int j = L; j > 0; --j) {
                if(a[j] == 0) {
                    isL = true;
                    SL = j;
                    break;
                }
            }
            for (int j = R; j <= S; ++j) {
                if(a[j] == 0) {
                    isr = true;
                    SR = j;
                    break;
                }
            }
            cout << SL << " " << SR << endl;
        }
        cout << "-" << endl;
    }
    return 0;
}